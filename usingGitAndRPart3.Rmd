---
title: 'Linking R and GitHub: part 3'
author: "Simon Brewer"
date: "10/16/2020"
output:
  html_document:
    theme: flatly
    df_print: paged
    number_sections: true
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(png)
library(grid)
```

# Working with branches in git

[NEEDS REVIEW]
Sometimes you want to make big changes to your code without having to disturb your main stream of development. Maybe you want to break it up into multiple simple commits so you can easily track what you’re doing. Maybe you’re not sure what you’ve done is the best approach and you want someone else to review your code. Or, maybe you want to try something experimental (you can merge it back only if the experiment succeeds). 

When you initialize a git repository, this is created with a single branch, the default. This is shown whenever anyone visits your repository, and is the initial branch that you get when you clone a repository. In general, you should consider this as the official working version of your project, and you should not work with this branch in a collaborative project. By default, GitHub names the default branch `main` in any new repository (previously this was `master`).

> Do not mess with the master. If you make changes to the master branch of a group project while other people are also working on it, your on-the-fly changes will ripple out to affect everyone else and very quickly there will be merge conflicts, weeping, rending of garments, and plagues of locusts. It’s that serious.
Unless you specify a different branch, the default branch in a repository is the base branch for new pull requests and code commits.[^1]

In a collaborative project, you should create new branches for each particular thing that you are working on. For example, each person can check out their own branch, or you can have a branch for each feature that is being added to a project. When the work on that particular feature is complete and tested, it can then be rolled back into the default `main` branch and made available there. git manages branches through a system of *checkouts* that create new branches, and *pull requests* that propose a set of changes to a higher level branch. Once the pull request has been accepted and the branch is merged back, then the branch should be deleted.

In this example, a default repository (`master`) has been established (green line). Two branches are then checked out, each set up to work on a single new feature (`feature1`, `feature2`). When feature 1 is complete, this is merged back to the `master` branch, through a pull request, followed by a second merge for feature 2. 

```{r echo=FALSE, fig.asp=0.55}
img <- readPNG("images/branches0.png")
grid.raster(img)
```

Fig: Example of git repository with two branches (https://digitalvarys.com/git-branch-and-its-operations/)

Note that it is also possible to checkout from a lower-level branch. If, for example, you have a working version of a new feature, you might want to check out a new branch based on this, where you could add an additional feature, or new method. This does not affect the working version, *and* doesn't mess with the main branch. In this example, a second branch is checked out from `feature1`, then merged back prior to the intermediate branch. The subsequent merge of this with the main branch will include all changes. 

```{r echo=FALSE, fig.asp=0.25}
img <- readPNG("images/branches1.png")
grid.raster(img)
```

Fig: Example with sub-branches (https://docs.github.com)

If the intermediate branch is merged back and deleted, the lower level branch will be automatically re-assigned to the next higher level branch

```{r echo=FALSE, fig.asp=0.25}
img <- readPNG("images/branches2.png")
grid.raster(img)
```

Fig: Example with loss of higher level branch (https://docs.github.com)

In the next section, we're going to look briefly at how to work with branches through the terminal (in case you want to work with non-R files), and then we'll go through the steps of working with branches through RStudio. 

## Working with branches from the terminal

Open a terminal and change to one of your existing repositories. For example:

```
cd /Users/username/Desktop/github/myrepo
```

You can get a list through the terminal by typing `git branch -a`. If you try this for any of your existing repositories, you should see something like the following, indicating that only the main branch exists. 

```
* main
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
```

We are now going to make a new branch of this repository. I'm going to call it `devel` to represent a development branch, but feel free to use a different/more amusing name. To create this, simply type:

```
git checkout -b devel
```

As long as there is no existing branch with this name, you should see the following message:

```
    Switched to a new branch 'devel'
```

You can also use `git checkout` to switch between branches. To go back to the main branch:

```
git checkout main
```

And to switch back to the new branch:

```
git checkout devel
```

If you now run `git branch -a`, you should see the following output (or close to it):

```
* devel
  main
  remotes/origin/HEAD -> origin/main
  remotes/origin/main
```

The `*` represent a pointer and indicates the current working repository. Make sure that this is pointing to your new branch, and then let's add a file

```
touch myLittlePonyScript.txt
```

This will just create a blank text file in your repository (sorry - the script is a secret). If you run `git status`, it should list this file as an untracked change. Let's now add it to the branch and commit:

```
git add myLittlePonyScript.txt
git commit -m "Added example text file"
```

To demonstrate that this has not affected your `main` branch, first get the list of files from the new branch

```
git ls-files
```

Now change to the main branch, and list the associated files

```
git checkout main
git ls-files
```

And you should **not** see the new file listed. You can also at this point add some text to the new file. Note that you need to change back to the new branch to do this:

```
git checkout devel
echo "Once upon a time in the land of Equestria..." >> myLittlePonyScript.txt
```

Then stage and commit this change:

```
git add myLittlePonyScript.txt
git commit -m "Added introduction..."
```

Once you have finished making all the changes, we can merge this back to the `main` branch. Remember that this would usually be done when you have checked and tested any changes you've made, and your code is production ready. If it is not, it is better to keep it on the working or development branch. 

In order to merge, *you need to be on the branch you want to merge to.* In this example, that means moving back to the `main` branch

```
git checkout main
git branch
```

If you are sure you are in the right place, we can now merge the `devel` branch using `git merge`. For this we need to specify the branch we want to use. We also include the `--no-ff` argument to copy over all the previous commits from this branch. Run the following command in the terminal

```
git merge devel --no-ff
```

And you should see something similar to the following output if successful:

```
Merge made by the 'recursive strategy'.
 myLittlePonyScript.txt | 1 ++
 1 file changed, 1 insertion(+)
 create model 100644 myLittlePonyScript.txt
```

Finally, we need to push the changes to GitHub:

```
git push
```

Once you see the confirmation notice, go to your GitHub page and check that the changes are visible there. 

Note: you can make branches using the SHA1 hash numbers of previous commits. This is an excellent way to go back and check some old code prior to resetting or reverting. For example:

```
git checkout 7c709f0
```

## Working with branches in RStudio


# Dealing with conflicts

While merging will work well most of the time, conflicts can occur if a file if the same part of the same file is changed on both branches that you are trying to merge.

git merge issue-5
# Auto-merging index.html
# CONFLICT (content): Merge conflict in index.html
# Automatic merge failed; fix conflicts and then commit the result.
The first thing to do is NOT PANIC. Merge conflicts are not the end of the world and most are relatively small and straightforward to resolve.

The first step to solving a merge conflict is determining which files are in conflict, which you can do with git status:

git status
# On branch master
# You have unmerged paths.
#   (fix conflicts and run "git commit")
# 
# Unmerged paths:
#   (use "git add <file>..." to mark resolution)
# 
#     both modified:      index.html
# 
# no changes added to commit (use "git add" and/or "git commit -a")
So this shows only index.html is unmerged and needs to be resolved. We can then open the file to see what lines are in conflict.

<<<<<<< HEAD:index.html
<div id="footer">contact : email.support@github.com</div>
=======
<div id="footer">
 please contact us at support@github.com
</div>
>>>>>>> issue-5:index.html
In this conflict, the lines between <<<<<< HEAD:index.html and ====== are the content from the branch you are currently on. The lines between ======= and >>>>>>> issue-5:index.html are from the feature branch we are merging.

To resolve the conflict, edit this section until it reflects the state you want in the merged result. Pick one version or the other or create a hybrid. Also remove the conflict markers <<<<<<, ====== and >>>>>>.

<div id="footer">
please contact us at email.support@github.com
</div>
Now run git add index.html and git commit to finalize the merge. CONFLICTS RESOLVED.

## Bailing out

If, during the merge, you get confused about the state of things or make a mistake, use git merge --abort to abort the merge and go back to the state prior to running git merge. Then you can try to complete the merge again.


# Working with others

So far, we have looked at using git to work with your code and a hosting service to have both an online and local copy of your code. While this can be a useful way to work to keep track of the progress you make while working, git really shines when using it to collaborate with others. There are three main ways to use git for collaboration

- Cloning a copy
- Forking a copy 
- Working as a team

We'll look at each of these in turn, using the repositories you made at the end of the previous lab. You'll need to work in pairs or small groups for this lab.

# Cloning a copy

Cloning simply refers to making an exact copy of the current state of a repository to your own local computer, including information on the commits made to that repository. The main limitation to this approach is that the cloned repository is independent of the original, so any changes you make cannot be easily integrated into the original using git, but would have to be added by hand. Further, this means that if the code in the original repository is changed, this will not propagate to your copy. So why do this? If your main interest is in making a copy that you can develop separately to the original (i.e. changing the purpose or application of the code) then this is a great approach. It is also quite useful if you just want to check someones code to see how they tackled a given problem. It is also a fairly straightforward operation (we previously looked at how to clone someone else's GitHub repository from the command line). 

## Cloning in RStudio

To clone an existing repository in RStudio, we simply proceed in the same way as we would to set up a new project, with the exception that we do not need to make the new repository on GitHub first. Simply open RStudio, change to the directory holding your local repositories and start a new project. Click on [Version Control], then [Git] (Clone a project from a Git repository). 

Now go to your partner's GitHub page and find the repository you want to copy. Click on the green [Code] button and copy the URL. Go back to RStudio and and enter this in the box labeled [Repository URL]. For the next box, either accept the given project directory name (this should be the same as the GitHub repository) or change this to a new one. The final box gives the directory where the repository will be cloned to on your computer. Make sure this is ok, and that the check-box [Start in new session] is checked. Now click [Create project] to make the new project, which should be automatically populated with the files from your partner's repository. 

Note that cloning a repo in this way does **not** add it to your GitHub account (if you check your page you won't see it there). To add it:

- Go to your GitHub page
- Create a new repository with *exactly* the same name as your RStudio project
- Do not check `Initialize this repository with a README`
- Click [Create Project]

Next, go to RStudio and open the R project file from the repository that you just cloned. 
Open a shell by clicking [Tools] > [Shell], then run the following commands:

```
git remote set-url origin https://github.com/USERNAME/REPOSITORY.git
git branch -M main
git push -u origin main
```

Check that all this works, then delete this repository before moving to the next part. As a reminder, you need to delete the local folder holding the repository, then go to the GitHub page > [Settings], and scroll down to the danger zone at the end of the page. Click [Delete the repository] and follow the prompts. 

# Forking a copy

```{r echo=FALSE, fig.asp=0.5}
img <- readPNG("images/forking.png")
grid.raster(img)
```

Forking serves two purposes in git. First, it allows endless amounts of Good Place jokes and second it allows you to copy another person's repository, but retain a link to the original repository. This is an ideal solution if you want to contribute code to an existing project. Forking creates your own local and remote repository and you can modify the code and commit it using the methods we have previously looked at. This allows several people to be working independently on a project, but without access to the official repository. Only the project maintainer can push to the official repository, and can then decide which of the commits proposed by developers get included in the official version. 

## Forking with RStudio

The first step is to fork the repository of interest on GitHub. Go to your partner's GitHub page and find the repository of interest. On the landing page, look for the [Fork] button on the right-hand side of the page. This will make a new forked copy and take you to that page. If you look under the repository anme on the left hand side of the page you should see something like `forked from USERNAME`. Now you have this, you can clone it to your computer to create the local repo. You probably know the routine by now, but click on the green [Code] button and copy the URL. Open RStudio, go to [File] > [New Project]. Then click on [Version Control], select [Git] and enter the URL on the next page that appears. 

. For this next section, you are again going to work in pairs

- Cloning repo
- Pull requests
- Merging
- Resolving (?)


In the previous section, we went through the somewhat laborious steps of setting up your computer to talk to GitHub. We will now look at how collaborate with someone else on your repository, and the use of GitHub pages. 

You can get a list of the branches for any repository by going to the GitHub page and clicking on the [master] button in the top left. This will show you a drop down list of the existing branches. 

[^1]: https://thenewstack.io/dont-mess-with-the-master-working-with-branches-in-git-and-github/

[g4wID]: https://gitforwindows.org
[gitID]: https://git-scm.com/downloads
[hgwrID]: https://happygitwithr.com
[ghID]: https://github.com
